import{_ as s,c as n,o as a,a3 as p}from"./chunks/framework.JR-NCfhW.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge-points/knowledges.md","filePath":"knowledge-points/knowledges.md","lastUpdated":1714381328000}'),e={name:"knowledge-points/knowledges.md"},l=p(`<div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>实例化挂载过程：</span></span>
<span class="line"><span>​	初始化工具方法、生命周期</span></span>
<span class="line"><span>​	挂载，执行 render 生成虚拟 DOM，并 update patch 虚拟变真实 DOM 结构，渲染到页面中</span></span>
<span class="line"><span></span></span>
<span class="line"><span>State 初始化顺序：inject -&gt; props -&gt; methods -&gt; data -&gt; computed -&gt; watch -&gt; provide</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Created 和 Mounted 请求数据有啥区别：前者可能请求到了并渲染上。后者可能渲染后才请求到，触发了两次 patch</span></span>
<span class="line"><span></span></span>
<span class="line"><span>If 和 For 同时带来的问题：首先是受先后顺序影响，其次在满足条件时循环的情况下，会造成多余浪费，先循环后判断</span></span>
<span class="line"><span></span></span>
<span class="line"><span>首屏加载慢：</span></span>
<span class="line"><span>​	原因：延迟、资源大，渲染内容多</span></span>
<span class="line"><span>​	解决方法：分包、静态资源缓存、按需加载、图片压缩雪碧图整合、gzip、代码整理、ssr</span></span>
<span class="line"><span></span></span>
<span class="line"><span>新属性、数组下标赋值不触发响应式：$set、\\$forcecUpdated()本身和插入插槽内容的子组件</span></span>
<span class="line"><span></span></span>
<span class="line"><span>组件和插件的区别：引入 / install安装、功能性封装 / 单例挂载到原型对象并提供 API</span></span>
<span class="line"><span></span></span>
<span class="line"><span>组件通信：Props、Emits、$parent、Attrs / Listeners、Provide / Inject、EventBus</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$nextTick 顺序：Promise、MutationObserver、setImmediate、setTimeout</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mixins 策略：</span></span>
<span class="line"><span>​	替换：props、methods、inject、computed</span></span>
<span class="line"><span>​	合并：data</span></span>
<span class="line"><span>​	队列：生命周期、watch</span></span>
<span class="line"><span>​	叠加(原型链)：component、directives、filters</span></span>
<span class="line"><span></span></span>
<span class="line"><span>key 作用：在复杂变动的时候根据它进行比较、强制刷新。没有则在同类型节点但内容不同时会多次操作 dom</span></span>
<span class="line"><span></span></span>
<span class="line"><span>是否缓存控制：判断 meta.keepAlive 来控制渲染在 keep-alive 里还是外面</span></span>
<span class="line"><span></span></span>
<span class="line"><span>自定义指令：防抖节流、图片懒加载</span></span>
<span class="line"><span></span></span>
<span class="line"><span>虚拟 Dom：HTML 转 AST 对象，业务处理，根据需求生成需要的代码</span></span>
<span class="line"><span>​	可跨端，定制化转换流程。</span></span>
<span class="line"><span>​	可以进行比较优化，减少 Dom 操作</span></span>
<span class="line"><span></span></span>
<span class="line"><span>vm 自身 Watcher：保存 vm._watchr = this。更改触发 render 并 patch</span></span>
<span class="line"><span>computed：</span></span>
<span class="line"><span>​	computed 是从 vm 拿的数据，computed / render  依赖数据</span></span>
<span class="line"><span>​	数据变 -&gt; 通知 render，对依赖的 computed dirty = true，获取时重新计算</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Diff：深度优先，同层比较</span></span>
<span class="line"><span>​	patch：没有新--销毁。没有旧--新建。同节点--patchVnode，否则销毁创建返回新 dom 元素</span></span>
<span class="line"><span>​	patchVnode：</span></span>
<span class="line"><span>​		不处理：新旧一样、异步占位符、静态节点(key, isCloned | isOnce)</span></span>
<span class="line"><span>​		节点：都有 childs，更新 childs。有新，则往旧 el 新增节点。有旧，删除所有 childs。都没有，清空文本内容</span></span>
<span class="line"><span>​		文本：不同则更改</span></span>
<span class="line"><span>​		hooks：prepatch -&gt; update(backend 钩子 + 自身) -&gt; postpatch。</span></span>
<span class="line"><span>​	updateChildren：</span></span>
<span class="line"><span>​		当前旧节点不存在：左右移动</span></span>
<span class="line"><span>​		新旧相同：patchVnode，并移动指针。前前、后后。前后、后前，并移动真实 dom 位置</span></span>
<span class="line"><span>​		复杂移动：生成 key Map，有就读取，没有就查找。找不到或不同就创建，继续 patchVnode，并清空旧 vnode移动到前面位置</span></span>
<span class="line"><span></span></span>
<span class="line"><span>为什么封装 axios：通用基础配置、规范返回格式，并对异常统一处理。拦截器顺序：请求：后 -- 前，响应：前 -- 后</span></span>
<span class="line"><span></span></span>
<span class="line"><span>取消请求：1.CancelToken.source() 作为 cancelToken 值传入，调用返回值取消。2. new CancelToken(cb) 回调接住方法</span></span>
<span class="line"><span></span></span>
<span class="line"><span>跨域：CORS、Proxy( proxy_pass )</span></span>
<span class="line"><span>404：location /  {    index  /data/dist/index.html;  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Vue3 区别：composition api、组件 ( Teleport、Suspense )，响应处理、虚拟 Dom 实现、字面量事件缓存、ts</span></span>
<span class="line"><span></span></span>
<span class="line"><span>响应式</span></span>
<span class="line"><span>​	Vue2 ：新增/删除 属性、数组下标赋值、操作 不触发，还要递归访问代理，数据过大有性能问题</span></span>
<span class="line"><span>​	Vue3：对象基本都能代理，深对象采用懒转换</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ES6</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var、let、const 区别：变量提升、暂时性死区、块级作用域、重复声明、修改声明的变量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WeakMap：key 弱引用，value 会随着 key 销毁</span></span>
<span class="line"><span></span></span>
<span class="line"><span>迭代器：定义一个方法，返回带有 next 函数的对象，next 返回 value 和 done</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Proxy：代理对象，进行拦截和自定义。Reflect：具有代理的所有方法，让方法调用结果变得合理，让对象操作变成函数行为</span></span></code></pre></div>`,1),t=[l];function c(i,o,d,r,m,h){return a(),n("div",null,t)}const k=s(e,[["render",c]]);export{_ as __pageData,k as default};
