import{_ as e,c as i,o as t,a3 as r}from"./chunks/framework.CqX4AtrM.js";const u=JSON.parse('{"title":"MagicString","description":"","frontmatter":{},"headers":[],"relativePath":"vue-perimeter/magicString.md","filePath":"vue-perimeter/magicString.md","lastUpdated":1714383234000}'),a={name:"vue-perimeter/magicString.md"},n=r('<h1 id="magicstring" tabindex="-1">MagicString <a class="header-anchor" href="#magicstring" aria-label="Permalink to &quot;MagicString&quot;">​</a></h1><p><strong>为了规避替换代码用重量级 AST，提出的轻量级方案</strong></p><ul><li>addsourcemaplocation：如果hires为false，将指定的字符索引（相对于原始字符串）添加到源映射</li><li>append / prepend：追加内容、前缀</li><li>appendLeft / appendRight(idx, ctx)：按照索引位置追加内容</li><li>clone：拷贝内容</li><li>generateDecodeMap：生成含有数组形式的 map</li><li>generateMap({ file: 编写源映射中的文件名, source: 包含原始源文件的文件名, includeContent: 是否包含原始内容, hires：是否精确到列，默认行 }) .toString / toUrl：生成 stringify map、包含源映射的DataURI</li><li>hasChanged()/.isEmpty()：是否更改/空</li><li>indent(prefix, [{ exclude: [star, end]}])：每一行前面加前缀</li><li>move(star, end idx)：范围内容移动到索引</li><li>rependLeft / rependRight(idx, ctx)：与追加相同，但内容会插入之前追加、前置的前面</li><li>replace/.replaceAll( regexpOrString, substitution: 替换 )：改变了魔术字符串的状态（使用.clone（）使其不可变）</li><li>remove：删除范围内容，重复、重叠内容删除会出错</li><li>slice：获取范围切片，索引用于已删除字符，则引发错误</li><li>snip：返回范围外的克隆内容</li><li>trim/.trimStart/.trimEnd/.trimLines：删除空白、空行</li><li>overwrite(star, end, ctx[ ,{ storeName: 存储原始名称, contentOnly: 是否只覆盖内容 }])：范围内容覆盖</li><li>update(star, end, ctx[ ,{ storeName: 存储原始名称, overwrite：附加内容是否与原始内容一起覆盖 }])：s.update(s,e,ctx) 等效 s.overwrite(s,e,ctx,{contentOnly:true})</li></ul>',3),l=[n];function s(c,o,d,p,m,g){return t(),i("div",null,l)}const h=e(a,[["render",s]]);export{u as __pageData,h as default};
