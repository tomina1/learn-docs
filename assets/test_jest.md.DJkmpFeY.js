import{_ as n,c as s,o as a,a3 as p}from"./chunks/framework.D3J-DHIV.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"test/jest.md","filePath":"test/jest.md","lastUpdated":1714439628000}'),e={name:"test/jest.md"},l=p(`<p>全局设定</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>beforeAll / beforeEach / afterEach / afterAll (fn, timeout)：所有前后/开始前后钩子、超时时间 = default 5s</span></span>
<span class="line"><span>describe(name, fn)：测试分类，可嵌套</span></span>
<span class="line"><span>describe.each(tableData)(name, fn, timeout)：绑定二维数据源，依次遍历调用测试</span></span>
<span class="line"><span></span></span>
<span class="line"><span>describe.only(name, fn)：运行指定 describe 块，其他会跳过</span></span>
<span class="line"><span>describe.only.each(table)(name, fn)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>describe.skip(name, fn)：注释代码，不会执行</span></span>
<span class="line"><span>describe.skip.each(table)(name, fn)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 测试单例</span></span>
<span class="line"><span>test(name, fn, timeout)：单个测试</span></span>
<span class="line"><span>alias：it(name, fn, timeout)</span></span>
<span class="line"><span>test.each(table)(name, fn, timeout)：批量数据进行测试</span></span>
<span class="line"><span>alias：it.each(table)(name, fn) 和 it.each\`table\`(name, fn)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>test.failing(name, fn, timeout)：失败测试，反向的</span></span>
<span class="line"><span>alias：it.failing(name, fn, timeout)</span></span>
<span class="line"><span>test.failing.each(name, fn, timeout)</span></span>
<span class="line"><span>alias：it.failing.each(table)(name, fn) and it.failing.each\`table\`(name, fn)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>test.only.failing(name, fn, timeout)</span></span>
<span class="line"><span>test.skip.failing(name, fn, timeout)</span></span>
<span class="line"><span>test.only(name, fn, timeout)</span></span>
<span class="line"><span>test.only.each(table)(name, fn)</span></span>
<span class="line"><span>test.skip(name, fn)</span></span>
<span class="line"><span>test.skip.each(table)(name, fn)</span></span>
<span class="line"><span>test.todo(name)：将要计划写的测试用例说明</span></span></code></pre></div><p>断言</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>expect(val)：配合匹配器函数来断言某个值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>not：取反方向</span></span>
<span class="line"><span>resolves：包裹处理 promise，拒绝则失败。该判断为异步，结合 async/await 使用</span></span>
<span class="line"><span>rejects：包裹异常 promise，成功则失败。也为异步</span></span>
<span class="line"><span></span></span>
<span class="line"><span>toBe(val)：检查 元值、对象实例地址值 是否相等</span></span>
<span class="line"><span>toHaveBeenCalled：检查是否被 调用</span></span>
<span class="line"><span>toBeCalled</span></span>
<span class="line"><span>toHaveBeenCalledTimes：检查 调用次数</span></span>
<span class="line"><span>toBeCalledTimes</span></span>
<span class="line"><span>toHaveBeenCalledWith/toHaveBeenLastCalledWith：检查 调用/最后调用 参数一致性</span></span>
<span class="line"><span>toBeCalledWith/lastCalledWith</span></span>
<span class="line"><span>toHaveBeenNthCalledWith(nCall, arg1, ...)：检查第 n 次调用的参数</span></span>
<span class="line"><span>nthCalledWith</span></span>
<span class="line"><span></span></span>
<span class="line"><span>toHaveReturned：有返回值，且不抛错</span></span>
<span class="line"><span>toReturn</span></span>
<span class="line"><span>toHaveReturnedTimes(num)：返回次数</span></span>
<span class="line"><span>toReturnTimes</span></span>
<span class="line"><span>toHaveReturnedWith(val)：检查返回值</span></span>
<span class="line"><span>toReturnWith</span></span>
<span class="line"><span>toHaveLastReturnedWith(val)：最后一次返回值</span></span>
<span class="line"><span>lastReturnedWith</span></span>
<span class="line"><span>toHaveNthReturnedWith(nCall, val)：检查第 n 次返回值</span></span>
<span class="line"><span>nthReturnedWith</span></span>
<span class="line"><span>toHaveLength(number)：检查 arr | str 长度大小</span></span>
<span class="line"><span>toHaveProperty(keyPath: str | str[], val?)：判断是否有属性、值比较，支持点深度写法</span></span>
<span class="line"><span>toBeCloseTo(num, numDigits)：数字以 n 精度判断</span></span>
<span class="line"><span>toBeDefined：检查返回值为 not undefined</span></span>
<span class="line"><span>toBeFalsy：检查是否为假值，null | undefined | &quot;&quot; | false | 0 | NaN</span></span>
<span class="line"><span>toBeTruthy：检查是否为真值</span></span>
<span class="line"><span>toBeGreaterThan/toBeGreaterThanOrEqual/toBeLessThan/toBeLessThanOrEqual(num | bigInt)：&gt;、&gt;=、&lt;、&lt;= 值</span></span>
<span class="line"><span>toBeInstanceOf(Class)：类似 instanceof</span></span>
<span class="line"><span>toBeNull：类似 toBe(null)，更加友好</span></span>
<span class="line"><span>toBeUndefined：类似 toBe(undefined)</span></span>
<span class="line"><span>toBeNaN：类似 toBe(NaN)</span></span>
<span class="line"><span>toContain(item | str)：是否包含 数组项/字符</span></span>
<span class="line"><span>toContainEqual(item)：是否包含特定结构和值的项，item 描述结构</span></span>
<span class="line"><span>toEqual(val)：递归比较其所有属性是否相等。忽略 未定义属性、数组项/数组稀疏性/对象类型不匹配的对象键</span></span>
<span class="line"><span>toStrictEqual：严格比较 { a:undefined } != {}</span></span>
<span class="line"><span>toMatch(reg | str)：对字符串内容进行匹配</span></span>
<span class="line"><span>toMatchObject(obj | obj[])：对象属性匹配、在数组对应位置上的对象属性匹配</span></span>
<span class="line"><span>toMatchSnapshot(propertyMatchers?, hint?)</span></span>
<span class="line"><span>toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)</span></span>
<span class="line"><span>toThrow(error?)：抛出的错误，reg | str | err 匹配 err msg 内容是否包含，err class 则判断是否同一类型</span></span>
<span class="line"><span>toThrowErrorMatchingSnapshot(hint?)</span></span>
<span class="line"><span>toThrowErrorMatchingInlineSnapshot(inlineSnapshot)</span></span></code></pre></div><p>不对称 - 匹配器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>toEqual / toBeCalledWith 里使用</span></span>
<span class="line"><span>expect.anything()：表示任何非 null / undefined 的值</span></span>
<span class="line"><span>expect.any(constructor)：匹配任何由构造器创建的对象，包括原始值类型</span></span>
<span class="line"><span>expect.arrayContaining(expectedArr)：匹配任何预期 数组 的子集，及包含预期所有 内容</span></span>
<span class="line"><span>expect.not.arrayContaining(expectedArr)</span></span>
<span class="line"><span>expect.stringMatching(string | regexp)：创建匹配器，匹配字符串。arrayContaining(stringMatcher[]) 匹配对应位置</span></span>
<span class="line"><span>expect.not.stringMatching(string | regexp)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>expect.closeTo(number, numDigits?)：创建数字用于精度丢失比较，仅比较数值时用 toBeCloseTo</span></span>
<span class="line"><span>expect.objectContaining(object)：匹配任何预期 对象 的子集，及包含预期所有 属性</span></span>
<span class="line"><span>expect.not.objectContaining(object)</span></span>
<span class="line"><span>expect.stringContaining(string)：是否包含所需的字符串</span></span>
<span class="line"><span>expect.not.stringContaining(string)</span></span></code></pre></div><p>断言次数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>expect.assertions(number)：检查是否断言了 n 次</span></span>
<span class="line"><span>expect.hasAssertions()：断言 &gt;= 1 次以上</span></span></code></pre></div><p>模拟函数：<code>mockFn</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>getMockName：返回通过调用 mockName 设置的模拟名称字符串</span></span>
<span class="line"><span>mock.calls(arr[][])：多次调用的参数集合</span></span>
<span class="line"><span>mock.results：多次调用返回的集合 { type: &quot;return&quot; | &quot;throw&quot;, value: Result | Error }[]</span></span>
<span class="line"><span>mock.instances：实例化对象集合</span></span>
<span class="line"><span>mock.contexts：调用的 thisCtx 集合</span></span>
<span class="line"><span>mock.lastCall：最后一次调用</span></span>
<span class="line"><span>mockClear：清空 mock.calls/results/instances/contexts，并重置、替换原有 mockFn.mock</span></span>
<span class="line"><span>mockReset：执行 mockClear，并替换 mock 为 NOOP</span></span>
<span class="line"><span>mockRestore：执行 mockReset，并还原 ( 非 mock ) 实现</span></span>
<span class="line"><span>mockImplementation(fn)：用作 mock 实现函数，但自身还会记录等逻辑</span></span>
<span class="line"><span>mockImplementationOnce(fn)：注册单次不同实现，并在执行后跳过</span></span>
<span class="line"><span>mockName(name)：用来在错误时标记出错位置名</span></span>
<span class="line"><span>mockReturnThis：类似 jest.fn(function () { return this; });</span></span>
<span class="line"><span>mockReturnValue(val)：设置返回值，在调用时返回。类似 jest.fn().mockImplementation(() =&gt; value)</span></span>
<span class="line"><span>mockReturnValueOnce(val)</span></span>
<span class="line"><span>mockResolvedValue(val)：设置异步返回值。类似 jest.fn().mockImplementation(() =&gt; Promise.resolve(value))</span></span>
<span class="line"><span>mockResolvedValueOnce(val)</span></span>
<span class="line"><span>mockRejectedValue(val)</span></span>
<span class="line"><span>mockRejectedValueOnce(val)</span></span>
<span class="line"><span>withImplementation(fn, cb)：临时捆绑回调时的 mock 和 cb</span></span>
<span class="line"><span></span></span>
<span class="line"><span>spyOn()</span></span>
<span class="line"><span>Spied&lt;Source&gt;</span></span></code></pre></div><p>Jest 对象</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>方法</span></span>
<span class="line"><span>disableAutomock/enableAutomock：关闭/开启 自动模拟模块请求并 mock，返回真实版本</span></span>
<span class="line"><span>createMockFromModule(url)：导入模块 mock datas。函数：NOOP、class：模仿、对象：深度克隆并 mock、数组：[]、值：相同值</span></span>
<span class="line"><span>mock(moduleName, factory?, options?：{ virtual： &quot;创建虚拟模块&quot;， shallow: true })：url，自动 mock 为 NOOP 函数。实则拦截代理模块导入的内容为实现。先替换后导入</span></span>
<span class="line"><span>factory 自定义 imp 实现</span></span>
<span class="line"><span>Mock&lt;T&gt;：fn 的实现类型</span></span>
<span class="line"><span>mocked(source, options?)</span></span>
<span class="line"><span>Mocked&lt;T&gt;、MockedClass&lt;T&gt;、MockedFunction&lt;T&gt;、MockedObject&lt;T&gt;：包裹对象后的 mock 类型</span></span>
<span class="line"><span>unmock(moduleName)：不会返回一个 mocked 的版本模块</span></span>
<span class="line"><span>dontMock(moduleName)：避免置顶</span></span>
<span class="line"><span>deepUnmock(moduleName)：不返回被 mocked 的版本及其依赖项</span></span>
<span class="line"><span>doMock(moduleName, factory, options)：避免 mock 调用置顶。用 import 必须声明 __esModule： true，使用 import() 不会置顶</span></span>
<span class="line"><span>setMock(moduleName, moduleExports)：手动 mock，已适合当前所讨论的模块</span></span>
<span class="line"><span>requireActual(moduleName)：导入真实 module，结合 mock 实现代理和扩展</span></span>
<span class="line"><span>requireMock(moduleName)：返回 mock module</span></span>
<span class="line"><span>resetModules：重置模块注册表-所有必需模块的缓存。返回一个新模块而非命中缓存</span></span>
<span class="line"><span>isolateModules(fn)：为 fn 的调用提供沙箱隔离，比 resetModules 更直接</span></span>
<span class="line"><span>isolateModulesAsync(fn)：为 async fn 的调用提供沙箱隔离</span></span>
<span class="line"><span></span></span>
<span class="line"><span>模拟函数</span></span>
<span class="line"><span>fn&lt;T&gt;(implementation?)：传入实现推导，或定义实现类型。创建新的 mock 函数</span></span>
<span class="line"><span>isMockFunction(fn)：是否为 mock fn</span></span>
<span class="line"><span>replaceProperty(object, propertyKey, value)：替换存在属性并返回新值，可以在 afterEach 中使用 restoreAllMocks 重置</span></span>
<span class="line"><span>Replaced&lt;T&gt;：调用 replaceProperty 后返回的实体类型</span></span>
<span class="line"><span>spyOn(object, methodName, accessType?：&#39;get&#39; | &#39;set&#39; )：监视方法，返回一个 mock fn 并替换实现。即在其他文件依赖时替换</span></span>
<span class="line"><span>Replaced&lt;Source&gt;</span></span>
<span class="line"><span>clearAllMocks：相当于对于每个 mock fn 调用 mockClear</span></span>
<span class="line"><span>resetAllMocks：相当于对于每个 mock fn 调用 mockReset</span></span>
<span class="line"><span>restoreAllMocks：对每个函数 mockRestore，属性 restore。适用于 spyOn、replaceProperty 操作</span></span>
<span class="line"><span></span></span>
<span class="line"><span>假的定时器</span></span>
<span class="line"><span>useFakeTimers(fakeTimersConfig?)：假的定时器。代替 Date、per.now、queueMicrotask、setImmediate、clearImmediate setInterval、clearInterval、setTimeout、clearTimeout</span></span>
<span class="line"><span>useRealTimers</span></span>
<span class="line"><span>runAllTicks：耗尽队列中及其中产生的微任务</span></span>
<span class="line"><span>runAllTimers：耗尽队列中及其中产生的宏任务</span></span>
<span class="line"><span>runAllTimersAsync新/runAllImmediates旧：假定时器可用</span></span>
<span class="line"><span>advanceTimersByTime/advanceTimersByTimeAsync新(msToRun)：所有计时器都提取 msToRun 毫秒</span></span>
<span class="line"><span>runOnlyPendingTimers：清空宏任务等待队列，不包含额外产生</span></span>
<span class="line"><span>runOnlyPendingTimersAsync新：promise 队列，类似上个</span></span>
<span class="line"><span>advanceTimersToNextTimer(steps)：计时器提前所需的毫秒，以便只运行下一个超时/间隔</span></span>
<span class="line"><span>advanceTimersToNextTimerAsync(steps)新：如上，promise</span></span>
<span class="line"><span>clearAllTimers：清空队列所有挂起的计时器</span></span>
<span class="line"><span>getTimerCount：返回假计时器数量</span></span>
<span class="line"><span>now</span></span>
<span class="line"><span>setSystemTime(now?: number | Date)新：设置系统时间</span></span>
<span class="line"><span>getRealSystemTime新：真实事件</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Misc</span></span>
<span class="line"><span>getSeed：获取种子值。及类似随机数</span></span>
<span class="line"><span>isEnvironmentTornDown：测试环境被破坏，则 false</span></span>
<span class="line"><span>retryTimes(numRetries, options?：{logErrorsBeforeRetry: true})：执行 n 次失败测试，直到结束、n 次</span></span>
<span class="line"><span>setTimeout(timeout)：设置所有 测试、挂钩 的超时时间</span></span></code></pre></div>`,12),t=[l];function i(c,o,r,m,u,d){return a(),s("div",null,t)}const g=n(e,[["render",i]]);export{k as __pageData,g as default};
